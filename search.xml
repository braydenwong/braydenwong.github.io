<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java如何实现线程交替执行?]]></title>
    <url>%2F2021%2F03%2F02%2FJava%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[单例模式的8种写法区别]]></title>
    <url>%2F2021%2F01%2F12%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%848%E7%A7%8D%E5%86%99%E6%B3%95%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[适用场景：无状态的工具类，很多工具类我们只需要一个实例，节省内存。但是大家的写法非常多，正确的写法却很少看见，希望看完这篇文章能够帮你梳理清楚。饿汉式：不管你用的用不上，一开始就建立这个单例对象(就像一个饥饿的人)懒汉式：是在你真正用到的时候才去建这个单例对象(就像一个懒惰的人) 1.饿汉式（静态常量）【可用】12345678910111213141516/** * 描述： 饿汉式（静态常量）（可用） */public class Singleton1 &#123; private final static Singleton1 INSTANCE = new Singleton1(); private Singleton1() &#123; &#125; public static Singleton1 getInstance() &#123; return INSTANCE; &#125;&#125; 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。 2.饿汉式（静态代码块）【可用】123456789101112131415161718/** * 描述： 饿汉式（静态代码块）（可用） */public class Singleton2 &#123; private final static Singleton2 INSTANCE; static &#123; INSTANCE = new Singleton2(); &#125; private Singleton2() &#123; &#125; public static Singleton2 getInstance() &#123; return INSTANCE; &#125;&#125; 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。 3.懒汉式(线程不安全)【不可用】123456789101112131415161718/** * 描述： 懒汉式（线程不安全） */public class Singleton3 &#123; private static Singleton3 instance; private Singleton3() &#123; &#125; public static Singleton3 getInstance() &#123; if (instance == null) &#123; instance = new Singleton3(); &#125; return instance; &#125;&#125; 这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会多次创建实例。所以在多线程环境下不可使用这种方式。 4.懒汉式(线程安全，同步方法)【不推荐用】123456789101112131415161718/** * 描述： 懒汉式（线程安全）（不推荐） */public class Singleton4 &#123; private static Singleton4 instance; private Singleton4() &#123; &#125; public synchronized static Singleton4 getInstance() &#123; if (instance == null) &#123; instance = new Singleton4(); &#125; return instance; &#125;&#125; 解决上面第三种实现方式的线程不安全问题，做个线程同步就可以了，于是就对getInstance()方法进行了线程同步。缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。 5.懒汉式(线程安全，同步代码块)【不可用】1234567891011121314151617181920/** * 描述： 懒汉式（线程不安全）（不推荐） */public class Singleton5 &#123; private static Singleton5 instance; private Singleton5() &#123; &#125; public static Singleton5 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton5.class) &#123; instance = new Singleton5(); &#125; &#125; return instance; &#125;&#125; 由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。 6.双重检查【推荐用】12345678910111213141516171819202122/** * 描述： 双重检查（推荐面试使用） */public class Singleton6 &#123; private volatile static Singleton6 instance; private Singleton6() &#123; &#125; public static Singleton6 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton6.class) &#123; if (instance == null) &#123; instance = new Singleton6(); &#125; &#125; &#125; return instance; &#125;&#125; Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象。这里的synchronized不能采用synchronized（this），因为getInstance是一个静态方法，在它内部不能使用未静态的或者未实例的类对象。优点：线程安全；延迟加载；效率较高。 6.1 为什么要double-check6.1.1 需要第二重的原因考虑这样一种情况，就是有两个线程同时到达，即同时调用getInstance()方法，此时由于instance == null，所以很明显，两个线程都可以通过第一重的singleton== null，进入第一重if语句后，由于存在锁机制，所以会有一个线程进入lock语句并进入第二重 singleton == null，而另外的一个线程则会在lock语句的外面等待。而当第一个线程执行完new Singleton（）语句后，便会退出锁定区域，此时，第二个线程便可以进入lock语句块，此时，如果没有第二重singleton == null的话，那么第二个线程还是可以调new Singleton（）语句，这样第二个线程也会创建一个Singleton实例，这样也还是违背了单例模式的初衷的，所以这里必须要使用双重检查锁定。 6.1.2 需要第一重的原因细心的朋友一定会发现，如果去掉第一重singleton == null，程序还是可以在多线程下安全运行的。考虑在没有第一重 singleton == null 的情况：当有两个线程同时到达，此时，由于 lock 机制的存在，假设第一个线程会进入lock语句块，并且可以顺利执行new Singleton（），当第一个线程退出lock语句块时，singleton这个静态变量已不为 null 了，所以当第二个线程进入lock时，会被第二重singleton == null挡在外面，而无法执行new Singleton（），以在没有第一重singleton == null的情况下，也是可以实现单例模式的。那么为什么需要第一重singleton == null呢？这里就涉及一个性能问题了，因为对于单例模式的话，new Singleton（）只需要执行一次就 OK 了，而如果没有第一重singleton == null的话，每一次有线程进入getInstance（）时，均会执行锁定操作来实现线程同步，这是非常耗费性能的，而如果我加上第一重singleton == null的话，那么就只有在第一次执行锁定以实现线程同步，而以后的话，便只要直接返回 Singleton 实例就OK了，而根本无需再进入lock语句块了，这样就可以解决由线程同步带来的性能问题了。 6.1.3 为什么要用volatile主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话做了下面 3 件事情：1.给instance分配内存2.调用Singleton的构造函数来初始化成员变量3.将instance对象指向分配的内存空间（执行完这步instance就为非null了）但是在JVM的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，已经线程一被调度器暂停，此时线程二刚刚进来第一重检查，看到的 instance 已经是非 null 了（但却没有初始化，里面的值可能是null/false/0，总之不是构造函数中指定的值），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错或者是看到了非预期的值（因为此时属性的值是默认值而不是所需要的值）。不过，如果线程一已经从把synchronized 同步块的代码都执行完了，那么此时instance一定是正确构造后的实例了，这是由synchronized的heppens-before保证的。 7.静态内部类【推荐用】1234567891011121314151617/** * 描述： 静态内部类方式，可用 */public class Singleton7 &#123; private Singleton7() &#123; &#125; private static class SingletonInstance &#123; private static final Singleton7 INSTANCE = new Singleton7(); &#125; public static Singleton7 getInstance() &#123; return SingletonInstance.INSTANCE; &#125;&#125; 这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。优点：避免了线程不安全，延迟加载，效率高。 8.枚举【推荐用】12345678910/** * 描述： 枚举单例 */public enum Singleton8 &#123; INSTANCE; public void whatever() &#123; &#125;&#125; 借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，还是懒加载，而且还能防止反序列化重新创建新的对象。 9.结论枚举最好。《Effective Java》中明确表达过的观点：“使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。” 10.为什么推荐枚举10.1 写法简单枚举比任何其他的写法都简单，很优雅。 10.2 线程安全有保障我们定义的一个枚举，在第一次被真正用到的时候，会被虚拟机加载并初始化，而这个初始化过程是线程安全的。而我们知道，解决单例的并发问题，主要解决的就是初始化过程中的线程安全问题。所以，由于枚举的以上特性，枚举实现的单例是天生线程安全的。 10.3 避免反序列化破坏单例普通的Java类的反序列化过程中，会通过反射调用类的默认构造函数来初始化对象。所以，即使单例中构造函数是私有的，也会被反射给破坏掉。由于反序列化后的对象是重新new出来的，所以这就破坏了单例。但是，枚举的反序列化并不是通过反射实现的。所以，也就不会发生由于反序列化导致的单例破坏问题。]]></content>
  </entry>
  <entry>
    <title><![CDATA[解析面试难点String的intern方法]]></title>
    <url>%2F2020%2F12%2F30%2F%E8%A7%A3%E6%9E%90%E9%9D%A2%E8%AF%95%E9%9A%BE%E7%82%B9String%E7%9A%84intern%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[网上对于intern方法的讨论很多是不对或者不严谨的，于是我参考了大量官方资料总结了该知识点，希望可以讲清楚。这个面试考点主要考察JVM的内存模型、对String类理解的深度以及字符串常量池的了解。 一.字符串常量池介绍在JAVA语言中有8种基本类型和一种比较特殊的类型String，其实String是引用类型，把它们归为一类是因为这些类型在运行过程中为了速度更快，更节省内存，都提供了一种常量池的概念。常量池就类似一个JAVA系统级别提供的缓存。8种基本类型的常量池都是系统协调的，String类型的常量池(String类对应的叫作字符串常量池)比较特殊。jdk6中字符串常量池在永久代，从jdk7开始放到了堆空间中(是堆中又划分了一块区域，注意这个细节!)。它的主要使用方法（或者说如何保证变量指向的是字符串常量池中的数据）有两种：1.直接使用双引号声明出来的String对象会直接存储在常量池中。String s = &quot;abc&quot;;2.如果不是用双引号声明的String对象，可以使用String提供的intern方法，这个下面会解释，先记住以下结论。字符串常量池存的东西有两种情况：1.字符串对象，比如上面的“abc”2.堆对象的引用。 二.intern方法介绍前置知识：1.字符串拼接的时候只要其中有一个是变量(非final修饰)，拼接出来的对象就在堆中，相当于在堆空间中new String(“XXX”)（不是在字符串常量池中）。变量拼接的原理是StringBuilder调用append方法然后再调用toString方法。2.new String(“ab”)会创建几个对象？两个对象，一个是在堆空间中，一个在字符串常量池中（字节码指令ldc）。有兴趣的小伙伴可以去看编译后的字节码文件。3.new String(“a”)+new String(“b”)呢？六个对象。有兴趣的小伙伴可以去看编译后的字节码文件。通过看字节码文件可知： 参考自官方文档：在jdk8中，intern方法的作用是如果字符串常量池已经包含一个等于(通过equals方法比较)此String对象的字符串，则返回字符串常量池中这个字符串的引用, 否则将当前String对象的引用地址（堆中对象的引用地址）添加（或者叫复制）到字符串常量池中并返回，这么做是为了节约堆空间，毕竟都在堆中。例如：String s = new String(&quot;s&quot;).intern();解读该行代码：new String(“s”)代表创建了两个对象，一个是在堆空间中，一个在字符串常量池中。new String(“s”).intern()则代表返回字符串常量池中的那个对象的引用赋给s变量。 三.面试题解析面试题如下，判断输出是true还是false。这里直接附上解析了，后面还有练习题。1234567891011String s = new String(&quot;1&quot;);s.intern();//调用此方法之前，字符串常量池中已经存在了“1”String s2 = &quot;1&quot;;System.out.println(s == s2);//jdk6:false jdk7/8:falseString s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);//s3变量记录的地址为：new String(&quot;11&quot;)，堆中。//执行完上一行代码以后，字符串常量池中，不存在“11”！！！s3.intern();//在字符串常量池中生成“11”。jdk6中，永久代中创建了一个新的对象“11”，也就有了新的地址。 //jdk7/jdk8中，此时常量中并没有创建“11”，而是添加一个指向堆空间中new String(&quot;11&quot;)的地址 String s4 = &quot;11&quot;;//s4变量记录的地址：使用的是上一行代码执行时，在字符串常量池中生成的“11”的地址System.out.println(s3 == s4);//jdk6:false jdk7/8:true 示意图： 四.String的intern方法总结 五.巩固练习1.12345String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);//new String(&quot;ab&quot;)String s2 = s.intern();//jdk6中，在串池中创建一个字符串“ab” //jdk7/8中，串池中没有创建字符串“ab”，而是创建一个引用，指向new String(&quot;ab&quot;)System.out.println(s2==&quot;ab&quot;);//jdk6:true jdk8:trueSystem.out.println(s==&quot;ab&quot;);//jdk6:false jdk8:true 2.1234String s1 = new String(&quot;ab&quot;);//会在字符串常量池中生成&quot;ab&quot;s1.intern();String s2 = &quot;ab&quot;;System.out.println(s1 == s2);//jdk8:false 参考资料：B站《尚硅谷JVM教程》美团技术：https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型简介]]></title>
    <url>%2F2020%2F09%2F14%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近我准备开始写Java并发编程相关系列的文章了，网上的博客五花八门，有些还是错的。所以本人查阅了大量并发编程领域的核心书籍及官方资料，目的就是要保证内容都具有一定“权威性”，想要学习Java多线程的同学可以多多关注下哈～&emsp;&emsp;首先需要区分两个概念：Java内存模型和Java内存结构。前者是和Java并发编程有关，后者是和Java虚拟机的运行时数据区有关，注意不要混淆。Java内存模型简称JMM(Java Memory Model)。 一.为什么需要并发编程&emsp;&emsp;上面提到Java内存模型是和Java并发编程有关的，那为什么需要并发编程呢？其实这是现代计算机硬件发展的必然趋势。&emsp;&emsp;1965年，英特尔创始人之一摩尔提出了摩尔定律，内容为：集成电路上可容纳的电晶体（晶体管）数目，约每隔24个月便会增加一倍。经常被引用的“18个月”，其实是英特尔首席执行官大卫豪斯所说的：预计18个月会将芯片的性能提高一倍（即更多的晶体管时其更快）。&emsp;&emsp;简单说，就是每18个月到24个月，我们的计算机性能就能翻倍。按照这种速度，人类的计算能力将会按照指数速度增长，未来我们甚至可以基于超级计算机模拟整个宇宙！&emsp;&emsp;摩尔定律的有效性超过了半个世纪，然而，摩尔定律并不是一种自然法则或物理定律，它只是基于人为观测数据对未来的预测。在2004年，Intel宣布将4GHz芯片推迟到2005年，但是在2004年秋季，Intel宣布彻底取消4GHz计划。&emsp;&emsp;为什么世界顶级的科技巨头要放弃4GHz的研发呢？因为当时的芯片制造工艺已经达到了纳米级别了，也许4GHz的芯片就已经接近理论极限了，再往下发展就显得有些困难。即使从目前的科技水平来看，CPU主频(或者叫时钟频率)的提升已经明显遇到了一些暂时不可逾越的瓶颈。因此摩尔定律在CPU的计算性能上可能已经“失效”。&emsp;&emsp;虽然CPU的性能已经接近止步，长达半个世纪的摩尔定律已经失效，但科学家和工程师依然没有停止不断前进的脚步。从2005年开始，我们已经不再追求单核的计算速度了，而着迷于研究如何将多个独立的计算单元整合到单独的CPU中，也就是我们所说的多核CPU。现在经过多年的发展，我们的CPU已经可以拥有4核心，甚至是8核心。从整体上看，专业服务器的内核总数甚至可以达到几百个。也就是说，因为处理器很难再提高它的主频，取而代之的是，处理器厂商会在一块芯片上放置更多的处理器内核。所有主要的芯片制造商都开始了这种转变，并且我们已经显著地看到机器中处理器数量的增加。非常令人激动，摩尔定律在另外一个侧面又“生效了”。&emsp;&emsp;好了，让我们回归标题。由于程序调度的基本单元是线程，一个单线程应用程序一次只能运行在一个处理器上。在双处理器系统中，一个单线程程序，放弃了其中一半的空闲CPU资源；在拥有100个处理器的系统中，这个单线程程序放弃了99%的资源。所以编写多线程程序就可以同时在多处理器上运行，有效利用空闲的处理器资源，提高吞吐量。&emsp;&emsp;不仅仅是多核CPU，在单核CPU中也支持编写多线程代码，CPU通过给每个线程分配CPU时间片来实现这个机制，并且也可以帮助我们实现更佳的吞吐量。如果一个程序是单线程的，这个处理器在等待一个I/O操作完成的时候，仍然是空闲的。在一个多线程程序中，当第一个线程等待I/O结束的同时，另外一个线程也可以运行，这样就使得应用程序在遇到I/O阻塞的时候仍然有进展。不过如果线程数非常多，CPU会在线程之间频繁地进行上下文切换，会影响多线程的执行速度，所以虽然支持但还是尽量用多核CPU。&emsp;&emsp;总结一下，由于芯片技术的瓶颈导致了摩尔定律的失效，所以为了继续保持性能的高速发展，硬件工程师想到了将多个CPU内核塞进一个CPU。所以在多核CPU的工作模式下，使用多线程编程才能更好的利用CPU资源，提高系统的吞吐率。 二.并发编程带来的挑战&emsp;&emsp;根据著名计算机科学家唐纳德的观点，摩尔定律本应该由硬件开发人员维持。但是，硬件工程师似乎已经无计可施，他们采用了多核处理器的设计，简化的硬件设计方案必然带来软件设计的复杂性。换句话说，软件工程师正在为硬件工程师无法完成的工作负责，因此，也就有了唐纳德的“他们将摩尔定律失效的责任推给了软件开发者”的说法。&emsp;&emsp;所以，如何让多核处理器有效并且正确地工作也就成了一门技术，甚至是很大的学问。比如，多线程间如何保证线程安全，如何正确理解线程间的无序性、可见性。对于并发编程的研究，逐渐被人们重视起来。&emsp;&emsp;那么，并发编程给软件工程师带来了哪些挑战呢？这要从现代CPU的硬件设计讲起。&emsp;&emsp;多核处理器是将多个CPU(称为“核”)集成到一个集成电路芯片上，如下图描述的是一个典型多核处理器的组织结构，其中微处理器芯片有4个CPU核，每个核都有自己的L1和L2高速缓存，其中的L1高速缓存分为两个部分：一个保存最近取到的指令，另一个存放数据。这些核共享更高层次的L3高速缓存，以及到主存的接口。&emsp;&emsp;从上图可以看出，计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。&emsp;&emsp;基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但它引入了一个新的问题：缓存一致性。在多核处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，这种系统称为共享内存多核系统，如下图所示，当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议又MSI、MESI、MOSI、Synapse等。&emsp;&emsp;由于主流程序语言(如C和C++等)直接使用物理硬件和操作系统的内存模型。因此，由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，所以《Java虚拟机规范》定义了一种“Java内存模型”，即定义Java内存模型来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致性的内存访问效果。 三.JMM是什么&emsp;&emsp;是一组规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。&emsp;&emsp;Java内存模型规定了所有的变量都存储在主内存中(类比操作系统的主内存)。每条线程还有自己的工作内存(类比前面讲的处理器高速缓存)，线程的工作内存中保存了主内存的变量副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图所示： 四.JMM的内容&emsp;&emsp;关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了下图中的8种操作来完成。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。具体的每个操作就不做阐述了，感兴趣的同学可以去查一下。&emsp;&emsp;JMM最重要的3点内容分别是重排序、内存可见性、原子性。因为这就是并发编程出现BUG的三大源头。接下来将会分三篇文章分别讲解这三部分内容。 参考书籍如下:《深入理解计算机系统》《深入理解Java虚拟机第三版》《实战Java高并发程序设计》《Java并发编程实战》《Java并发编程的艺术》]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾回收算法]]></title>
    <url>%2F2020%2F09%2F06%2F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[首先，需要先搞清楚两个问题。1.什么是垃圾？垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。2.为什么要进行垃圾收集？如果不即使对内存中的垃圾进行清理，那么垃圾对象所占的内存空间会保留到应用程序结束，甚至可能导致内存溢出。其次，垃圾收集是分阶段的，分为标记阶段和清除阶段。标记阶段作用是区分出内存中哪些是存活对象，哪些是已经死亡的对象，一般有两种方式：引用计数算法和可达性分析算法。清除阶段是当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便又足够的可用内存空间为新对象分配内存。目前JVM中比较常见的三种垃圾收集算法是标记-清除算法、复制算法、标记-压缩算法。 1.标记阶段:引用计数算法1.1概念每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1.只要对象A的引用计数器的值为0.即表示对象A不可能再被使用，可进行回收。 1.2优点实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。 1.3缺点它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。每次复制都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。引用计数器有一个严重的问题，即无法处理循环引用的情况。见下图：其中rc为引用计数器。正因为这个致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。但是在Python的垃圾回收中就使用了这个算法。Python如何解决循环引用？1.手动解除2.使用弱引用weakref，weakref是Python的标准库。 2.标记阶段:可达性分析算法2.1概念通过GC Roots的对象为起点，向下搜索，能到达的对象为不可回收对象，不能到达的对象为需要回收的对象。Java中就是通过可达性分析算法来判定对象是否存活的。这种算法就是Java、C#选择的。也叫根搜索算法、追踪行垃圾收集。GC Roots的对象1）、方法区中常量引用的对象；2）、方法区中类静态属性（static修饰）引用的对象；3）、虚拟机栈（本地变量表）中引用的对象（正在被使用）；4）、本地方法栈（native修饰方法）中引用的对象； 2.2优点解决了在引用计数算法中循环引用的问题，防止内存泄漏的发生。Java和C#就是用这种算法。 2.3缺点分析工作必须在一个保障一致性的快照中进行。这点不满足的分析结果的准确性就无法保证。这点也是导致GC进行时必须“Stop The World”的一个重要原因。 3.清除阶段:标记-清除算法当堆中的有效内存空间被耗尽的时候，就会停止整个程序（STW），然后进行两项工作，第一项是标记，第二项则是清除。需要注意的是这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次又新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。标记：从引用根节点开始便利，标记所有被引用的对象。一般是在对象的对象头中记录为可达对象。清除：对堆内存从头到尾进行线性的遍历，如果发现某个对象在对象头中没有标记为可达对象，则将其回收。 3.1缺点1.在进行GC的时候，需要停止整个应用程序，导致用户体验差。2.这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表。 4.清除阶段:复制算法将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。 4.1优点没有标记和清除过程，实现简单，运行高效。复制过去以后保证空间的连续性，不会出现碎片问题。 4.2缺点需要两倍的内存空间。 5.清除阶段:标记-压缩算法执行过程：第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象。第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后清理边界外所有空间。也叫标记-整理算法。 5.1优点解决了标记-清除算法中碎片问题。消除了复制算法中内存减半的高额代价。 5.2缺点效率上低于复制算法移动对象的同时，如果对象被其他对象引用根，则还需要调整引用的地址。 6.总结 7.分代收集算法 8.增量收集算法 9.分区算法]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[类的加载过程及注意点]]></title>
    <url>%2F2020%2F08%2F04%2F%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;类的加载过程主要分为三个阶段：加载、链接(验证，准备，解析)、初始化。&emsp;&emsp;网上有很多关于这一块的介绍和概念，但是要么不准确，要么就不够具体。如果单从概念上看是很难理解的，本文更多的是解释每个步骤的相关概念以加深同学们的理解。&emsp;&emsp;整体过程如下：&emsp;&emsp;先说一个java的命令，方便下面反编译看字节码文件：javap -v XXX.class，不仅会输出行号、本地变量表信息、反编译汇编代码，还会输出当前类用到的常量池等信息，。（也可以通过IDEA装插件的形式看,搜jclasslib）&emsp;&emsp;通过反编译看到的class文件中的常量池，加载到内存后叫运行时常量池。 一.加载先看概念：关于第一点需要补充一下：关于第二点方法区具体的实现要看jdk版本（jdk7-永久代，jdk8-元空间）。另外还需要知道生成大的class实例是在加载这个过程中出现的。 二.链接链接又分为三个步骤：验证、准备、解析。还是先看概念,然后逐点解释： 2.1 验证&emsp;&emsp;目的是防止恶意修改或攻击。&emsp;&emsp;举个例子就是：能够被java虚拟机识别的字节码文件都有一个专有标示，它的十六进制格式开头都有“CAFEBABE”，被称为Java class文件的魔数。&emsp;&emsp;额外说明：十六进制（简写为hex或下标16）在数学中是一种逢16进1的进位制。只能用数字0到9和字母A到F（或a~f）表示，其中:A~F表示10~15，这些称作十六进制数字。例如123123-&gt;1e0f3。&emsp;&emsp;再额外说明：在计算机领域，魔数有两个含义，一指用来判断文件类型的魔数；二指程序代码中的魔数，也称魔法值。所谓魔法值，是指在代码中直接出现的数值，只有在这个数值记述的那部分代码中才能明确了解其含义。例如阿里巴巴代码规约就会提示。&emsp;&emsp;为什么是CAFEBABE呢？&emsp;&emsp;网上猜测是Java一直以咖啡为代言，CAFEBABE可以认为是 Cafe Babe，读音上和Cafe Baby很近。所以这个也许就是代表Cafe Baby的意思。 2.2 准备主要是设置类变量的默认初始值，例如：123456public class A &#123; private static int a = 1;//准备阶段：a=0;-----&gt;初始化阶段a=1。 public static void main(String[] args) &#123; System.out.println(a); &#125;&#125; 数据类型不同，初始值不同。final修饰的static变量编译的时候就分配了，准备阶段会显示初始化。不会为实例变量分配初始化。 2.3 解析主要是符号引用转直接引用的过程，了解即可。 三.初始化还是先看概念，然后逐点解释：注：clinit=class initclinit方法不是我们自己定义的，通过反编译可以看到： 如何理解“顺序执行”呢？先看代码：123456789101112public class A &#123; private static int a = 1;//准备阶段：a=0;-----&gt;初始化阶段a=1。 static &#123; a = 2; b = 20; &#125; private static int b = 10;//为什么可以先赋值再定义？链接之准备阶段：b=0--&gt; 初始化：20--&gt;10 public static void main(String[] args) &#123; System.out.println(a);//2 System.out.println(b);//10 &#125;&#125; 下图为上面代码反编译后的字节码文件：从字节码文件可以看出是顺序执行的。如果代码里没有静态变量或者静态代码块，编译就不会有clinit方法。比如下图中的情况：所以可以看出类构造器方法clinit就是针对类变量的赋值和静态代码块的，如果没有就不会生成clinit方法。还有个init方法其实就是类的构造器。另外，需要注意的是下面的写法：前向引用可参考oracle官方文档：前向引用官方解释 概念中还提到：方法在多线程只会执行一次又是什么意思呢？看下面的例子： 12345678910111213141516171819202122 public class A &#123; public static void main(String[] args) &#123; Runnable runnable = () -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;开始&quot;); DeadThread deadThread = new DeadThread(); System.out.println(Thread.currentThread().getName() + &quot;开始&quot;); &#125;; Thread t1 = new Thread(runnable, &quot;线程1&quot;); Thread t2 = new Thread(runnable, &quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125;class DeadThread &#123; static &#123; if (true) &#123; System.out.println(Thread.currentThread().getName() + &quot;初始化当前类&quot;); while (true) &#123; &#125; &#125; &#125;&#125; 输出如下： 123线程2开始线程1开始线程2初始化当前类 部分代码和截图参考自B站视频。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[B+树]]></title>
    <url>%2F2020%2F07%2F23%2FB%2B%E6%A0%91%2F</url>
    <content type="text"><![CDATA[为了降低难度方便理解，概念先不用管，后面会总结，直接看例子：下图是B+树的结构，特点是：节点之间含有重复数据，叶子节点还用指针连在一起。其次，每个父节点的元素都出现在子节点中，是子节点的最大或最小元素。由于父节点的元素都出现在子节点，因此所有叶子节点包含了全量元素信息，并且每个叶子节点都带有指向下一节点的指针，形成了一个有序链表。卫星数据：指的是索引元素所指向的数据记录，比如数据库中的某一行。在B-树中，无论中间节点还是叶子节点都带有卫星数据：而在B+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联：补充一个知识点：在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。B+树设计成这样的好处主要体现在查询性能上，分两种情况讨论： 1.单行查询&emsp;&emsp;单行查询的时候，B+树会自顶向下逐层查找节点，最终找到匹配的叶子节点。比如我们要查找的是元素3：&emsp;&emsp;流程看起来和B-树差不多，但是有两点不同。&emsp;&emsp;首先B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素。这意味着，数据量相同的情况下，B+树的结构比B-树更加“矮胖”（可以理解为树的高度降低了，想象下矮胖的雪人和圣诞树），因此查询时IO次数也更少。&emsp;&emsp;其次，B+树的查询必须最终查找到叶子节点，而B-树只要找到匹配元素即可，无论元素处于中间节点还是叶子节点。因此，可以说B-树的查找性能并不稳定（最好情况是查根节点，最坏情况是查到叶子节点）。而B+树的每一次查找都是稳定的。 2.范围查询B-树只能依靠繁琐的中序遍历。比如我们要查询范围为3到11元素：而B+树的范围查询，则要简单得多，只需要在链表上做遍历即可：是不是简单很多？至于B+树的插入和删除，过程与B-树大同小异，不再详解。最后还是要说下B+树特征的专业偏抽象描述：1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。 最后的最后，总结下B+树的优势：1.单一节点存储更多的元素，使得查询的IO次数更少。2.所有查询都要查找到叶子节点，查询性能稳定。3.所有叶子节点形成有序链表，便于范围查询。 你的Q&amp;A：1.既然B+树这么好，还要B-树何用？？？（微笑脸）B-树的好处是，虽然查询性能不稳定，但平均的查询速度快一些（不用每次都查找到叶子节点为止）2.如何理解B+树“查询性能稳定”？B+树的查询每次都查到叶子节点，所以IO次数稳定。试想一个数据库的查询，有时候执行10毫秒，有时候执行100毫秒，肯定是不太合适的。还不如每次都执行30毫秒。3.看起来和跳跃表有点像？确实有点像呢，不过跳跃表的层数比B+树更多。可以比较下我另一篇跳跃表的文章。4.这算不算是以空间换时间呢？的确是以空间换时间。父节点元素在子节点重复出现，增加了少量空间，换来的是范围查询的便利。5.HashMap为什么不把红黑树改成b树？因为二叉查找树的查找效率是最高的，如果内存能装下完整的树，最好使用二叉查找树，b树是退而求其次的方式。 部分内容参考自公众号：程序员小灰]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[跳跃表(SkipList)]]></title>
    <url>%2F2020%2F07%2F23%2F%E8%B7%B3%E8%B7%83%E8%A1%A8-SkipList%2F</url>
    <content type="text"><![CDATA[跳跃表是一种基于有序链表的拓展，简称跳表。下面正式开始了哦，跟着思路来，非常简单理解: 一.基本思想给定一个有序链表：1-&gt;2-&gt;3-&gt;5-&gt;6-&gt;7-&gt;8跳表的思想就是利用了类似索引的思想，提取出链表中的部分关键节点，然后再用二分查找。上面的有序链表，把奇数作为关键节点提取出来：现在要插入一个值为4的节点，传统的做法是逐一比较，现在只需要比较关键节点，3，5，7。确定了它在3和5之间的话就回原链表查找，迅速定位到对应的位置插入。上面的过程体现了跳表另外一个思想：以空间换时间。在数据量特别大的时候效果非常明显。 二.进一步优化上面只是介绍了基本思想，其实还可以继续优化，看到这别担心，难度不会增加，也非常好理解:既然上面提取了一层节点作为索引，那是不是也可以进一步提取？有了2级索引后，插入的节点可以先和2级索引比较，确定大体范围;然后再和1级索引比较;最后再回到原链表，找到并插入对应的位置。节点多的时候还可以进一步提取，保证每一层是上一层节点的一半。提取的极限是同一层只有两个节点的时候，因为一个节点比较没有意义。到这里，多层链表结构就提取完了，这就是跳跃表。 三.其他问题当大量新节点通过逐层比较插入到链表中后，上层节点就会显得不够用，这就需要从新节点中“提拔”一部分节点到上一层，问题就是“提拔”谁呢(如何选择索引)？跳表设计者采用了“抛硬币”的方法，随机决定新节点是否提拔。因为跳表的添加和删除的节点是不可预测的，很难用算法保证跳表的索引分布始终均匀。虽然抛硬币的方式不能保证绝对均匀，但大体上是趋于均匀的。比如说，9插入到链表后，开始分析： 跳跃表插入操作的时间复杂度是O（logN），而这种数据结构所占空间是2N，既空间复杂度是 O（N）。 四.删除的情况删除的时候只要在索引层找到要删除的节点，然后删除每一层相同的节点即可。如果某一层删到只剩下一个，那么整层都可以删掉。比如删除5:跳跃表删除操作的时间复杂度是O（logN）。 五.跳跃表和二叉查找树的对比跳表维持结构平衡的成本较低，完全靠随机。二叉查找树在多次插入和删除后需要重新保持自平衡。 六.应用Redis的五种数据类型之一Sorted-set(zset)这种有序集合，正是对于跳跃表的改进和应用。还有Java中的ConcurrentSkipListMap和ConcurrentSkipListSet内部都是用跳表的数据结构。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2020重新营业啦!]]></title>
    <url>%2F2020%2F07%2F22%2F2020%E9%87%8D%E6%96%B0%E8%90%A5%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[很高兴认识你，今天我决定重新运营我的个人网站!本站建于2018年，写了些文章，2019年几乎没动，于是今年打算重新整理，删除了部分文章，作为2020的新开始。本网站主要是写一些技术文章，但也会穿插一些生活中的随笔，希望可以得到你的关注哦～]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[oauth2]]></title>
    <url>%2F2018%2F11%2F29%2Foauth2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;以前公司的物业管理app项目用到了oauth2作为安卓端和服务器端的安全认证协议，一开始拿到这套代码是一脸懵逼的，因为当时完全没有接触过oauth相关的开发，那么只有一条路——自学。通过查找资料看文档，慢慢地对oauth2熟悉了，这段时间虽然很痛苦但是成长是非常快的。&emsp;&emsp;当时公司是用这个项目——oauth2-shiro做的oauth2二次开发，用到了shiro相关知识，好吧，又是一个盲区，于是shiro也学会了~这份源码我是一步一步地打断点看流程，最后才弄懂整个流程，不得不佩服作者的设计，真的是太巧妙了，后来还好奇去查了这位称号为monkeyk的作者，原来是四川某知名互联网的技术总监！&emsp;&emsp;对于oauth2的相关基本概念，建议直接看这篇来自阮一峰的文章——理解OAuth 2.0。&emsp;&emsp;oauth2的应用场景十分广泛，比如在一些第三方的app或网站会提供微信登录的方式让用户扫码登录，只要你稍微留意一下跳转的url，你会看到url都会带有oauth2的字符串。&emsp;&emsp;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决eclipse使用lombok插件问题,最正确的解决方式！]]></title>
    <url>%2F2018%2F11%2F28%2F%E8%A7%A3%E5%86%B3eclipse%E4%BD%BF%E7%94%A8lombok%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98-%E6%9C%80%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%EF%BC%81%2F</url>
    <content type="text"><![CDATA[之前的公司项目需要用到微信开发sdk，sdk用到lombok，项目却一直报错，提示没有getter和setter方法。百度有很多解决方式，但各不一样，都不能奏效，最终解决方法在这：12-javaagent:lombok.jar具体目录-Xbootclasspath/a:lombok.jar具体目录 当然，你用idea的话这些都不是问题]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[oxygen版本jsp文件BUG问题]]></title>
    <url>%2F2018%2F11%2F26%2Foxygen%E7%89%88%E6%9C%ACjsp%E6%96%87%E4%BB%B6BUG%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; 引入c标签库并且也已经成功导入相应jar包后还是c标签报错，这时，可以看看自己的eclipse版本是否是oxygen。这是eclipse oxygen的一个bug，官方已经给出解决方法：https://bugs.eclipse.org/bugs/show_bug.cgi?id=518987#c0 点进去将下载的文件解压缩，找到plugins下面的jar包，然后找到本机eclipse安装目录，进入plugins ，org.eclipse.wst.html.core（后面可能有日期） 复制该jar包的文件名，将新的jar包名字改为此名字，并且替换掉原来jar，再次打开eclipse ，如果仍然报错，clean一下 。 一定要按上面步骤替换，不然据说可能替换后会导致eclipse异常!]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
</search>
