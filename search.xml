<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>类的加载过程及注意点</title>
      <link href="/2020/08/04/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
      <url>/2020/08/04/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>类的加载过程主要分为三个阶段：加载、链接(验证，准备，解析)、初始化。</strong><br>&emsp;&emsp;<strong>网上有很多关于这一块的介绍和概念，但是要么不准确，要么就不够具体。如果单从概念上看是很难理解的，本文更多的是解释每个步骤的相关概念以加深同学们的理解。</strong><br>&emsp;&emsp;<strong>整体过程如下：</strong><br><img src="https://res.insta360.com/static/assets/storage/20200804/ec68c2bf35b82c4cf90895bbd1385587/1596508468340.jpg" alt="alt"><br>&emsp;&emsp;先说一个java的命令，方便下面反编译看字节码文件：javap -v XXX.class，不仅会输出行号、本地变量表信息、反编译汇编代码，还会输出当前类用到的常量池等信息，。（也可以通过IDEA装插件的形式看,搜jclasslib）<br>&emsp;&emsp;通过反编译看到的class文件中的常量池，加载到内存后叫运行时常量池。<a id="more"></a></p><h1 id="一-加载"><a href="#一-加载" class="headerlink" title="一.加载"></a>一.加载</h1><p>先看概念：<br><img src="https://res.insta360.com/static/assets/storage/20200804/459094607eddc375c85033283ebe707d/WechatIMG119.jpeg" alt="alt"><br>关于第一点需要补充一下：<br><img src="https://res.insta360.com/static/assets/storage/20200804/31c9c49e66464f35b81364fea096f09c/WechatIMG120.png" alt="alt"><br>关于第二点方法区具体的实现要看jdk版本（jdk7-永久代，jdk8-元空间）。<br>另外还<font color="#FF0000">需要知道生成大的class实例是在加载这个过程中出现的。</font></p><h1 id="二-链接"><a href="#二-链接" class="headerlink" title="二.链接"></a>二.链接</h1><p>链接又分为三个步骤：验证、准备、解析。还是先看概念,然后逐点解释：<br><img src="https://res.insta360.com/static/assets/storage/20200804/2af02290bec1a163eff2686af1533b17/WechatIMG121.png" alt="alt"></p><h2 id="2-1-验证"><a href="#2-1-验证" class="headerlink" title="2.1 验证"></a>2.1 验证</h2><p>&emsp;&emsp;目的是防止恶意修改或攻击。<br>&emsp;&emsp;举个例子就是：能够被java虚拟机识别的字节码文件都有一个专有标示，它的十六进制格式开头都有“CAFEBABE”，被称为Java class文件的魔数。<br>&emsp;&emsp;额外说明：十六进制（简写为hex或下标16）在数学中是一种逢16进1的进位制。只能用数字0到9和字母A到F（或a~f）表示，其中:A~F表示10~15，这些称作十六进制数字。例如123123-&gt;1e0f3。<br>&emsp;&emsp;再额外说明：在计算机领域，魔数有两个含义，一指用来判断文件类型的魔数；二指程序代码中的魔数，也称魔法值。所谓魔法值，是指在代码中直接出现的数值，只有在这个数值记述的那部分代码中才能明确了解其含义。例如阿里巴巴代码规约就会提示。<br>&emsp;&emsp;为什么是CAFEBABE呢？<br>&emsp;&emsp;网上猜测是Java一直以咖啡为代言，CAFEBABE可以认为是 Cafe Babe，读音上和Cafe Baby很近。所以这个也许就是代表Cafe Baby的意思。</p><h2 id="2-2-准备"><a href="#2-2-准备" class="headerlink" title="2.2 准备"></a>2.2 准备</h2><p>主要是设置类变量的默认初始值，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    private static int a = 1;//准备阶段：a=0;-----&gt;初始化阶段a=1。</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数据类型不同，初始值不同。<br>final修饰的static变量编译的时候就分配了，准备阶段会显示初始化。<br>不会为实例变量分配初始化。</p><h2 id="2-3-解析"><a href="#2-3-解析" class="headerlink" title="2.3 解析"></a>2.3 解析</h2><p>主要是符号引用转直接引用的过程，了解即可。</p><h1 id="三-初始化"><a href="#三-初始化" class="headerlink" title="三.初始化"></a>三.初始化</h1><p>还是先看概念，然后逐点解释：<br><img src="https://res.insta360.com/static/assets/storage/20200804/3ac0e9629e7b64fca05e8d658ec0f7f6/WechatIMG122.png" alt="alt"><br>注：clinit=class init<br>clinit方法不是我们自己定义的，通过反编译可以看到：<br><img src="https://res.insta360.com/static/assets/storage/20200804/2d36a5cb97245bff37ca6a5de23bb54a/WechatIMG126.jpeg" alt="alt"></p><p>如何理解“顺序执行”呢？先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    private static int a = 1;//准备阶段：a=0;-----&gt;初始化阶段a=1。</span><br><span class="line">    static &#123;</span><br><span class="line">        a = 2;</span><br><span class="line">        b = 20;</span><br><span class="line">    &#125;</span><br><span class="line">    private static int b = 10;//为什么可以先赋值再定义？链接之准备阶段：b=0--&gt; 初始化：20--&gt;10</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(a);//2</span><br><span class="line">        System.out.println(b);//10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下图为上面代码反编译后的字节码文件：<br><img src="https://res.insta360.com/static/assets/storage/20200804/d6169d9cabde94ecb6a827ffb49aebf5/WechatIMG128.png" alt="alt"><br>从字节码文件可以看出是顺序执行的。<br><strong>如果代码里没有静态变量或者静态代码块，编译就不会有clinit方法。比如下图中的情况：</strong><br><img src="https://res.insta360.com/static/assets/storage/20200804/4b132250ac2abfe66e19ad1564139ebe/WechatIMG130.png" alt="alt"><br>所以可以看出类构造器方法clinit就是针对类变量的赋值和静态代码块的，如果没有就不会生成clinit方法。<br><strong>还有个init方法其实就是类的构造器。</strong><br>另外，需要注意的是下面的写法：<br><img src="https://res.insta360.com/static/assets/storage/20200804/66719a2036fbf139d561192bb60219da/WechatIMG129.png" alt="alt"><br>前向引用可参考oracle官方文档：<br><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.3" target="_blank" rel="noopener">前向引用官方解释</a>  </p><p><clinit>概念中还提到：方法在多线程只会执行一次又是什么意思呢？看下面的例子：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  public class A &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;开始&quot;);</span><br><span class="line">            DeadThread deadThread = new DeadThread();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;开始&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 = new Thread(runnable, &quot;线程1&quot;);</span><br><span class="line">        Thread t2 = new Thread(runnable, &quot;线程2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class DeadThread &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        if (true) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;初始化当前类&quot;);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></clinit></p><p>输出如下：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程2开始</span><br><span class="line">线程1开始</span><br><span class="line">线程2初始化当前类</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br><br><br></p><p>  部分代码和截图参考自B站视频。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>B+树</title>
      <link href="/2020/07/23/B+%E6%A0%91/"/>
      <url>/2020/07/23/B+%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>为了降低难度方便理解，概念先不用管，后面会总结，直接看例子：<br><br>下图是B+树的结构，特点是：节点之间含有重复数据，叶子节点还用指针连在一起。<a id="more"></a><br><img src="https://res.insta360.com/static/assets/storage/20200730/7b271bf2e8827f7c37a83d2e5ecec0af/image.png" alt=""><br>其次，每个父节点的元素都出现在子节点中，是子节点的最大或最小元素。<br><img src="https://res.insta360.com/static/assets/storage/20200730/8f14f72ad5ec4504e7ffd33f06884a86/image2.png" alt=""><br>由于父节点的元素都出现在子节点，因此所有叶子节点包含了全量元素信息，并且每个叶子节点都带有指向下一节点的指针，形成了一个有序链表。<br><img src="https://res.insta360.com/static/assets/storage/20200730/69a789d1bd26a49be6aa85bb64b5bdd3/image3.png" alt=""><br>卫星数据：指的是索引元素所指向的数据记录，比如数据库中的某一行。<br><br>在B-树中，无论中间节点还是叶子节点都带有卫星数据：<br><img src="https://res.insta360.com/static/assets/storage/20200730/060a0816a4154cd0765b75014d6467cb/image4.png" alt=""><br>而在B+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联：<br><img src="https://res.insta360.com/static/assets/storage/20200730/b42034cefca59d336c1f2de560e5a725/image5.png" alt=""><br>补充一个知识点：在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。<br><br>B+树设计成这样的好处主要体现在查询性能上，分两种情况讨论：<br></p><h3 id="1-单行查询"><a href="#1-单行查询" class="headerlink" title="1.单行查询"></a>1.单行查询</h3><p>&emsp;&emsp;单行查询的时候，B+树会自顶向下逐层查找节点，最终找到匹配的叶子节点。比如我们要查找的是元素3：<br><img src="https://res.insta360.com/static/assets/storage/20200730/6f21da7dd75490f9f57f6383675704f8/image6.png" alt=""><br><img src="https://res.insta360.com/static/assets/storage/20200730/3c1e3824925624508c1e5ce76c66b2f1/image7.png" alt=""><br><img src="https://res.insta360.com/static/assets/storage/20200730/7de1bb1d6cc99f3829128290eed4af84/image8.png" alt=""><br>&emsp;&emsp;流程看起来和B-树差不多，但是有两点不同。<br><br>&emsp;&emsp;首先B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素。这意味着，数据量相同的情况下，B+树的结构比B-树更加“矮胖”（可以理解为树的高度降低了，想象下矮胖的雪人和圣诞树），因此查询时IO次数也更少。<br><br>&emsp;&emsp;其次，B+树的查询必须最终查找到叶子节点，而B-树只要找到匹配元素即可，无论元素处于中间节点还是叶子节点。因此，可以说B-树的查找性能并不稳定（最好情况是查根节点，最坏情况是查到叶子节点）。而B+树的每一次查找都是稳定的。</p><h3 id="2-范围查询"><a href="#2-范围查询" class="headerlink" title="2.范围查询"></a>2.范围查询</h3><p>B-树只能依靠繁琐的中序遍历。比如我们要查询范围为3到11元素：<br><img src="https://res.insta360.com/static/assets/storage/20200730/1bb19eaf93beade2f63ba333beb502e8/image9.png" alt=""><br><img src="https://res.insta360.com/static/assets/storage/20200730/e3999a560dff0351d6b03883ce3c50d7/image10.png" alt=""><br><img src="https://res.insta360.com/static/assets/storage/20200730/434aa7ca1631473229b982cc8f09367d/image11.png" alt=""><br><img src="https://res.insta360.com/static/assets/storage/20200730/b45d2288e4408c53d9d0c0221e1a6b89/image12.png" alt=""><br><img src="https://res.insta360.com/static/assets/storage/20200730/5698b60486a4515e3725b2f3545666e3/image13.png" alt=""><br>而B+树的范围查询，则要简单得多，只需要在链表上做遍历即可：<br><img src="https://res.insta360.com/static/assets/storage/20200730/a0c7d07fe2f04dcf61f7c1d9148e9877/image14.png" alt=""><br><img src="https://res.insta360.com/static/assets/storage/20200730/da60afaee5d4dea03f743ab6cb016927/image15.png" alt=""><br><img src="https://res.insta360.com/static/assets/storage/20200730/d93f636d388527d948252e6bc09e9087/image16.png" alt=""><br>是不是简单很多？<br><br>至于B+树的插入和删除，过程与B-树大同小异，不再详解。<br><br>最后还是要说下B+树特征的专业偏抽象描述：<br><br>1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。<br><br>2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。<br><br>3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</p><p>最后的最后，总结下B+树的优势：<br><br>1.单一节点存储更多的元素，使得查询的IO次数更少。<br><br>2.所有查询都要查找到叶子节点，查询性能稳定。<br><br>3.所有叶子节点形成有序链表，便于范围查询。<br></p><p>你的Q&amp;A：<br><br><strong>1.既然B+树这么好，还要B-树何用？？？（微笑脸）</strong><br><br>B-树的好处是，虽然查询性能不稳定，但平均的查询速度快一些（不用每次都查找到叶子节点为止）<br><br><strong>2.如何理解B+树“查询性能稳定”？</strong><br><br>B+树的查询每次都查到叶子节点，所以IO次数稳定。试想一个数据库的查询，有时候执行10毫秒，有时候执行100毫秒，肯定是不太合适的。还不如每次都执行30毫秒。<br><br><strong>3.看起来和跳跃表有点像？</strong><br><br>确实有点像呢，不过跳跃表的层数比B+树更多。可以比较下我另一篇跳跃表的文章。<br><br><strong>4.这算不算是以空间换时间呢？</strong><br><br>的确是以空间换时间。父节点元素在子节点重复出现，增加了少量空间，换来的是范围查询的便利。<br><br><strong>5.HashMap为什么不把红黑树改成b树？</strong><br><br>因为二叉查找树的查找效率是最高的，如果内存能装下完整的树，最好使用二叉查找树，b树是退而求其次的方式。<br><br><br><br><br><br><br><br><br><br></p><p>部分内容参考自公众号：程序员小灰</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>跳跃表(SkipList)</title>
      <link href="/2020/07/23/%E8%B7%B3%E8%B7%83%E8%A1%A8-SkipList/"/>
      <url>/2020/07/23/%E8%B7%B3%E8%B7%83%E8%A1%A8-SkipList/</url>
      
        <content type="html"><![CDATA[<p>跳跃表是一种基于有序链表的拓展，简称跳表。<br>下面正式开始了哦，跟着思路来，非常简单理解:  </p><h2 id="一-基本思想"><a href="#一-基本思想" class="headerlink" title="一.基本思想"></a>一.基本思想</h2><p>给定一个有序链表：<br><code>1-&gt;2-&gt;3-&gt;5-&gt;6-&gt;7-&gt;8</code><br>跳表的思想就是利用了类似索引的思想，提取出链表中的部分关键节点，然后再用二分查找。<br><a id="more"></a>上面的有序链表，把奇数作为关键节点提取出来：<br><img src="https://res.insta360.com/static/assets/storage/20200730/8593a89f7a6c25f0ac0428fe4a4dd106/image.png" alt=""><br>现在要插入一个值为4的节点，传统的做法是逐一比较，现在只需要比较关键节点，3，5，7。<br><img src="https://res.insta360.com/static/assets/storage/20200730/9ae0c5003c90bd38b4e11851c28fe774/image2.png" alt=""><br>确定了它在3和5之间的话就回原链表查找，迅速定位到对应的位置插入。<br><img src="https://res.insta360.com/static/assets/storage/20200730/8d54c14d1919db2a3c86c95821a1e877/image3.png" alt=""><br>上面的过程体现了跳表另外一个思想：以空间换时间。在数据量特别大的时候效果非常明显。</p><h2 id="二-进一步优化"><a href="#二-进一步优化" class="headerlink" title="二.进一步优化"></a>二.进一步优化</h2><p>上面只是介绍了基本思想，其实还可以继续优化，看到这别担心，难度不会增加，也非常好理解:<br><br>既然上面提取了一层节点作为索引，那是不是也可以进一步提取？<br><br><img src="https://res.insta360.com/static/assets/storage/20200730/842afeb45f837e32099c3f339094346c/image4.png" alt=""><br>有了2级索引后，插入的节点可以先和2级索引比较，确定大体范围;然后再和1级索引比较;最后再回到原链表，找到并插入对应的位置。<br><br>节点多的时候还可以进一步提取，保证每一层是上一层节点的一半。提取的极限是同一层只有两个节点的时候，因为一个节点比较没有意义。<br><br>到这里，多层链表结构就提取完了，这就是跳跃表。</p><h2 id="三-其他问题"><a href="#三-其他问题" class="headerlink" title="三.其他问题"></a>三.其他问题</h2><p>当大量新节点通过逐层比较插入到链表中后，上层节点就会显得不够用，这就需要从新节点中“提拔”一部分节点到上一层，问题就是“提拔”谁呢(如何选择索引)？<br><br>跳表设计者采用了“抛硬币”的方法，随机决定新节点是否提拔。因为跳表的添加和删除的节点是不可预测的，很难用算法保证跳表的索引分布始终均匀。虽然抛硬币的方式不能保证绝对均匀，但大体上是趋于均匀的。<br><br>比如说，9插入到链表后，开始分析：<br><br><img src="https://res.insta360.com/static/assets/storage/20200730/cbff69aecd59fc8577187b23a85bd9ad/image5.png" alt=""></p><p><img src="https://res.insta360.com/static/assets/storage/20200730/26f9a49d913d16c037d28fde4c6a18eb/image6.png" alt=""></p><p><img src="https://res.insta360.com/static/assets/storage/20200730/c2f296adf6e6efe64e13e604bf8e46c8/image7.png" alt=""><br>跳跃表插入操作的时间复杂度是O（logN），而这种数据结构所占空间是2N，既空间复杂度是 O（N）。</p><h2 id="四-删除的情况"><a href="#四-删除的情况" class="headerlink" title="四.删除的情况"></a>四.删除的情况</h2><p>删除的时候只要在索引层找到要删除的节点，然后删除每一层相同的节点即可。如果某一层删到只剩下一个，那么整层都可以删掉。比如删除5:<br><br><img src="https://res.insta360.com/static/assets/storage/20200730/e651952d7702385abda23c269f1b4579/image8.png" alt=""><br>跳跃表删除操作的时间复杂度是O（logN）。</p><h2 id="五-跳跃表和二叉查找树的对比"><a href="#五-跳跃表和二叉查找树的对比" class="headerlink" title="五.跳跃表和二叉查找树的对比"></a>五.跳跃表和二叉查找树的对比</h2><p>跳表维持结构平衡的成本较低，完全靠随机。二叉查找树在多次插入和删除后需要重新保持自平衡。</p><h2 id="六-应用"><a href="#六-应用" class="headerlink" title="六.应用"></a>六.应用</h2><p>Redis的五种数据类型之一Sorted-set(zset)这种有序集合，正是对于跳跃表的改进和应用。<br>还有Java中的ConcurrentSkipListMap和ConcurrentSkipListSet内部都是用跳表的数据结构。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2020重新营业啦!</title>
      <link href="/2020/07/22/2020%E9%87%8D%E6%96%B0%E8%90%A5%E4%B8%9A/"/>
      <url>/2020/07/22/2020%E9%87%8D%E6%96%B0%E8%90%A5%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<p>很高兴认识你，今天我决定重新运营我的个人网站!<br>本站建于2018年，写了些文章，2019年几乎没动，于是今年打算重新整理，删除了部分文章，作为2020的新开始。<br>本网站主要是写一些技术文章，但也会穿插一些生活中的随笔，希望可以得到你的关注哦～</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>oauth2</title>
      <link href="/2018/11/29/oauth2/"/>
      <url>/2018/11/29/oauth2/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;以前公司的物业管理app项目用到了oauth2作为安卓端和服务器端的安全认证协议，一开始拿到这套代码是一脸懵逼的，因为当时完全没有接触过oauth相关的开发，那么只有一条路——自学。通过查找资料看文档，慢慢地对oauth2熟悉了，这段时间虽然很痛苦但是成长是非常快的。<a id="more"></a><br>&emsp;&emsp;当时公司是用这个项目——<a href="https://github.com/monkeyk/oauth2-shiro" target="_blank" rel="noopener">oauth2-shiro</a>做的oauth2二次开发，用到了shiro相关知识，好吧，又是一个盲区，于是shiro也学会了~这份源码我是一步一步地打断点看流程，最后才弄懂整个流程，不得不佩服作者的设计，真的是太巧妙了，后来还好奇去查了这位称号为monkeyk的作者，原来是四川某知名互联网的技术总监！<br>&emsp;&emsp;对于oauth2的相关基本概念，建议直接看这篇来自阮一峰的文章——<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">理解OAuth 2.0</a>。<br>&emsp;&emsp;oauth2的应用场景十分广泛，比如在一些第三方的app或网站会提供微信登录的方式让用户扫码登录，只要你稍微留意一下跳转的url，你会看到url都会带有oauth2的字符串。<br>&emsp;&emsp;</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>解决eclipse使用lombok插件问题,最正确的解决方式！</title>
      <link href="/2018/11/28/%E8%A7%A3%E5%86%B3eclipse%E4%BD%BF%E7%94%A8lombok%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98-%E6%9C%80%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%EF%BC%81/"/>
      <url>/2018/11/28/%E8%A7%A3%E5%86%B3eclipse%E4%BD%BF%E7%94%A8lombok%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98-%E6%9C%80%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>之前的公司项目需要用到微信开发sdk，sdk用到lombok，项目却一直报错，提示没有getter和setter方法。百度有很多解决方式，但各不一样，都不能奏效，最终解决方法在这：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:lombok.jar具体目录</span><br><span class="line">-Xbootclasspath/a:lombok.jar具体目录</span><br></pre></td></tr></table></figure></p><p><strong>当然，你用idea的话这些都不是问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>oxygen版本jsp文件BUG问题</title>
      <link href="/2018/11/26/oxygen%E7%89%88%E6%9C%ACjsp%E6%96%87%E4%BB%B6BUG%E9%97%AE%E9%A2%98/"/>
      <url>/2018/11/26/oxygen%E7%89%88%E6%9C%ACjsp%E6%96%87%E4%BB%B6BUG%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;</span><br></pre></td></tr></table></figure><p>引入c标签库并且也已经成功导入相应jar包后还是c标签报错，这时，可以看看自己的eclipse版本是否是oxygen。<strong>这是eclipse oxygen的一个bug</strong>，官方已经给出解决方法：<br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=518987#c0" target="_blank" rel="noopener">https://bugs.eclipse.org/bugs/show_bug.cgi?id=518987#c0</a></p><p><a id="more"></a>点进去将下载的文件解压缩，找到plugins下面的jar包，然后找到本机eclipse安装目录，进入plugins ，org.eclipse.wst.html.core（后面可能有日期） 复制该jar包的文件名，将新的jar包名字改为此名字，并且替换掉原来jar，再次打开eclipse ，如果仍然报错，clean一下 。</p><p><strong>一定要按上面步骤替换，不然据说可能替换后会导致eclipse异常!</strong></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
