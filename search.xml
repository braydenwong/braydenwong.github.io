<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[B+树]]></title>
    <url>%2F2020%2F07%2F23%2FB-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[为了降低难度方便理解，概念先不用管，后面会总结，直接看例子：下图是B+树的结构，特点是：节点之间含有重复数据，叶子节点还用指针连在一起。其次，每个父节点的元素都出现在子节点中，是子节点的最大或最小元素。由于父节点的元素都出现在子节点，因此所有叶子节点包含了全量元素信息，并且每个叶子节点都带有指向下一节点的指针，形成了一个有序链表。卫星数据：指的是索引元素所指向的数据记录，比如数据库中的某一行。在B-树中，无论中间节点还是叶子节点都带有卫星数据：而在B+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联：补充一个知识点：在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。B+树设计成这样的好处主要体现在查询性能上，分两种情况讨论： 1.单行查询&emsp;&emsp;单行查询的时候，B+树会自顶向下逐层查找节点，最终找到匹配的叶子节点。比如我们要查找的是元素3：&emsp;&emsp;流程看起来和B-树差不多，但是有两点不同。&emsp;&emsp;首先B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素。这意味着，数据量相同的情况下，B+树的结构比B-树更加“矮胖”（可以理解为树的高度降低了，想象下矮胖的雪人和圣诞树），因此查询时IO次数也更少。&emsp;&emsp;其次，B+树的查询必须最终查找到叶子节点，而B-树只要找到匹配元素即可，无论元素处于中间节点还是叶子节点。因此，可以说B-树的查找性能并不稳定（最好情况是查根节点，最坏情况是查到叶子节点）。而B+树的每一次查找都是稳定的。 2.范围查询B-树只能依靠繁琐的中序遍历。比如我们要查询范围为3到11元素：而B+树的范围查询，则要简单得多，只需要在链表上做遍历即可：是不是简单很多？至于B+树的插入和删除，过程与B-树大同小异，不再详解。最后还是要说下B+树特征的专业偏抽象描述：1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。 最后的最后，总结下B+树的优势：1.单一节点存储更多的元素，使得查询的IO次数更少。2.所有查询都要查找到叶子节点，查询性能稳定。3.所有叶子节点形成有序链表，便于范围查询。 你的Q&amp;A：1.既然B+树这么好，还要B-树何用？？？（微笑脸）B-树的好处是，虽然查询性能不稳定，但平均的查询速度快一些（不用每次都查找到叶子节点为止）2.如何理解B+树“查询性能稳定”？B+树的查询每次都查到叶子节点，所以IO次数稳定。试想一个数据库的查询，有时候执行10毫秒，有时候执行100毫秒，肯定是不太合适的。还不如每次都执行30毫秒。3.看起来和跳跃表有点像？确实有点像呢，不过跳跃表的层数比B+树更多。可以比较下我另一篇跳跃表的文章。4.这算不算是以空间换时间呢？的确是以空间换时间。父节点元素在子节点重复出现，增加了少量空间，换来的是范围查询的便利。5.HashMap为什么不把红黑树改成b树？因为二叉查找树的查找效率是最高的，如果内存能装下完整的树，最好使用二叉查找树，b树是退而求其次的方式。 部分内容参考自公众号：程序员小灰]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[跳跃表(SkipList)]]></title>
    <url>%2F2020%2F07%2F23%2F%E8%B7%B3%E8%B7%83%E8%A1%A8-SkipList%2F</url>
    <content type="text"><![CDATA[跳跃表是一种基于有序链表的拓展，简称跳表。下面正式开始了哦，跟着思路来，非常简单理解: 一.基本思想给定一个有序链表：1-&gt;2-&gt;3-&gt;5-&gt;6-&gt;7-&gt;8跳表的思想就是利用了类似索引的思想，提取出链表中的部分关键节点，然后再用二分查找。上面的有序链表，把奇数作为关键节点提取出来：现在要插入一个值为4的节点，传统的做法是逐一比较，现在只需要比较关键节点，3，5，7。确定了它在3和5之间的话就回原链表查找，迅速定位到对应的位置插入。上面的过程体现了跳表另外一个思想：以空间换时间。在数据量特别大的时候效果非常明显。 二.进一步优化上面只是介绍了基本思想，其实还可以继续优化，看到这别担心，难度不会增加，也非常好理解:既然上面提取了一层节点作为索引，那是不是也可以进一步提取？有了2级索引后，插入的节点可以先和2级索引比较，确定大体范围;然后再和1级索引比较;最后再回到原链表，找到并插入对应的位置。节点多的时候还可以进一步提取，保证每一层是上一层节点的一半。提取的极限是同一层只有两个节点的时候，因为一个节点比较没有意义。到这里，多层链表结构就提取完了，这就是跳跃表。 三.其他问题当大量新节点通过逐层比较插入到链表中后，上层节点就会显得不够用，这就需要从新节点中“提拔”一部分节点到上一层，问题就是“提拔”谁呢(如何选择索引)？跳表设计者采用了“抛硬币”的方法，随机决定新节点是否提拔。因为跳表的添加和删除的节点是不可预测的，很难用算法保证跳表的索引分布始终均匀。虽然抛硬币的方式不能保证绝对均匀，但大体上是趋于均匀的。比如说，9插入到链表后，开始分析： 跳跃表插入操作的时间复杂度是O（logN），而这种数据结构所占空间是2N，既空间复杂度是 O（N）。 四.删除的情况删除的时候只要在索引层找到要删除的节点，然后删除每一层相同的节点即可。如果某一层删到只剩下一个，那么整层都可以删掉。比如删除5:跳跃表删除操作的时间复杂度是O（logN）。 五.跳跃表和二叉查找树的对比跳表维持结构平衡的成本较低，完全靠随机。二叉查找树在多次插入和删除后需要重新保持自平衡。 六.应用Redis的五种数据类型之一Sorted-set(zset)这种有序集合，正是对于跳跃表的改进和应用。还有Java中的ConcurrentSkipListMap和ConcurrentSkipListSet内部都是用跳表的数据结构。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2020重新营业啦!]]></title>
    <url>%2F2020%2F07%2F22%2F2020%E9%87%8D%E6%96%B0%E8%90%A5%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[很高兴认识你，今天我决定重新运营我的个人网站!本站建于2018年，写了些文章，2019年几乎没动，于是今年打算重新整理，删除了部分文章，作为2020的新开始。本网站主要是写一些技术文章，但也会穿插一些生活中的随笔，希望可以得到你的关注哦～]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[oauth2]]></title>
    <url>%2F2018%2F11%2F29%2Foauth2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;以前公司的物业管理app项目用到了oauth2作为安卓端和服务器端的安全认证协议，一开始拿到这套代码是一脸懵逼的，因为当时完全没有接触过oauth相关的开发，那么只有一条路——自学。通过查找资料看文档，慢慢地对oauth2熟悉了，这段时间虽然很痛苦但是成长是非常快的。&emsp;&emsp;当时公司是用这个项目——oauth2-shiro做的oauth2二次开发，用到了shiro相关知识，好吧，又是一个盲区，于是shiro也学会了~这份源码我是一步一步地打断点看流程，最后才弄懂整个流程，不得不佩服作者的设计，真的是太巧妙了，后来还好奇去查了这位称号为monkeyk的作者，原来是四川某知名互联网的技术总监！&emsp;&emsp;对于oauth2的相关基本概念，建议直接看这篇来自阮一峰的文章——理解OAuth 2.0。&emsp;&emsp;oauth2的应用场景十分广泛，比如在一些第三方的app或网站会提供微信登录的方式让用户扫码登录，只要你稍微留意一下跳转的url，你会看到url都会带有oauth2的字符串。&emsp;&emsp;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决eclipse使用lombok插件问题,最正确的解决方式！]]></title>
    <url>%2F2018%2F11%2F28%2F%E8%A7%A3%E5%86%B3eclipse%E4%BD%BF%E7%94%A8lombok%E6%8F%92%E4%BB%B6%E9%97%AE%E9%A2%98-%E6%9C%80%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%EF%BC%81%2F</url>
    <content type="text"><![CDATA[之前的公司项目需要用到微信开发sdk，sdk用到lombok，项目却一直报错，提示没有getter和setter方法。百度有很多解决方式，但各不一样，都不能奏效，最终解决方法在这：12-javaagent:lombok.jar具体目录-Xbootclasspath/a:lombok.jar具体目录 当然，你用idea的话这些都不是问题]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[oxygen版本jsp文件BUG问题]]></title>
    <url>%2F2018%2F11%2F26%2Foxygen%E7%89%88%E6%9C%ACjsp%E6%96%87%E4%BB%B6BUG%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; 引入c标签库并且也已经成功导入相应jar包后还是c标签报错，这时，可以看看自己的eclipse版本是否是oxygen。这是eclipse oxygen的一个bug，官方已经给出解决方法：https://bugs.eclipse.org/bugs/show_bug.cgi?id=518987#c0 点进去将下载的文件解压缩，找到plugins下面的jar包，然后找到本机eclipse安装目录，进入plugins ，org.eclipse.wst.html.core（后面可能有日期） 复制该jar包的文件名，将新的jar包名字改为此名字，并且替换掉原来jar，再次打开eclipse ，如果仍然报错，clean一下 。 一定要按上面步骤替换，不然据说可能替换后会导致eclipse异常!]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
</search>
